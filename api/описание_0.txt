1) при подключении конвертера создается сокет
2) проверяем сокет на соответствие требованиям
3) получаем номер и модель конвертера, 
4) создаем объект конвертер с имененм модель+номер (obj)
5) в этот объект (obj) сохраняем ссылку на сокет (отправка и получение сообщений)
6) объекты:
converters = model+number=>(obj)
	используем конструктор конвертера
	- obj.data  - данные ответа,  
	- obj.socket  - отправка/получение сообщений 
	- obj.cmd(obj) - обработчик ответа конвертера(объект/метод), 
	- obj.tmr - общий таймер на сброс команды.
	- obj.lic_num - номер лицензии
	- obj.cmd_id - порядковый номер команды
	- obj.back - обработчик ответа функции (тот кто вызывал функцию)
объект контроллеры controllers = model+number=>(obj)
	используем конструктор контроллера
	адрес, модель, прошивка

конструктор конвертера
список свойств
список методов


Проверки
1) ошибки
2) контрольная сумма
3) номер команды

команда 
- это экземпляр генератора
создаем экземплял путь.имя (объект команды )

ГРУППИРОВКА  в таблице в базе
const  -  require,  проты, адреса, роли ....

флаги серверов  -  интерфейсы связи

сервера + их функции

Внешний API

Внутренний API - гененраторы

Функции для внутреннего API

Очередь и стэк
очередь это Set()  и  итератор
в очереди объекты => в объекте: свойство - это параметры, метод это функция

связи
obj.socket
obj.data
obj.model
obj.number
obj.mode
obj.key
obj.lic


converters[name]=new class
converters[name] => заполняем класс
инфо переносится, надо ли?
converters[name] = obj  - условно
возможно, переносить данные не нужно
converters[name].obj=obj 


цепь
сокет - конверер
вызовы
в команде ссылка на объект obj
по сокету - конвертер
по сокету  - сокет
по конвертеру сокет
obj - должен иметь ссылки на оба элемента сокет и конвертер

НУЖЕН конструктор  obj

obj=>
- сокет
- конвертер (по имени)
конструктор конвертер не нужен, нужна вставка новой функции, в зависимости от конвертера = декоратор









